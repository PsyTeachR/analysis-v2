## Solutions to Questions



Below you will find the solutions to the questions for the Activities for this chapter. Only look at them after giving the questions a good try and speaking to the tutor about any issues.

### Data Wrangling Basics

#### Task 1

* Using `select()` to include only stated columns:


```r
select(pong_data, Participant, PaddleLength, TrialNumber, BackgroundColor, HitOrMiss)
```

* Using `select()` to exclude certain columns:


```r
select(pong_data, -JudgedSpeed, -BallSpeed, -BlockNumber)
```

* Using `select()` to change the order of columns:


```r
select(pong_data, BallSpeed, HitOrMiss, JudgedSpeed, Participant, TrialNumber)
```

[Return to Task](#Ch2PreClassQueT1)

#### Task 2


```r
arrange(pong_data, desc(HitOrMiss), desc(JudgedSpeed))
```

[Return to Task](#Ch2PreClassQueT2)

#### Task 3


```r
filter(pong_data, 
       JudgedSpeed == 1, 
       BallSpeed %in% c("2", "4", "5", "7"), 
       HitOrMiss == 0)
```

[Return to Task](#Ch2PreClassQueT3)

#### Task 4

* first step is created with `filter()`
* the second step is created with `mutate()`


```r
pong_data_filt <- filter(pong_data, TrialNumber >= 2) 
pong_data2 <- mutate(pong_data_filt, TrialNumber = TrialNumber - 1)
```

[Return to Task](#Ch2PreClassQueT4)

#### Task 5


```r
group_by(pong_data2, BlockNumber, BackgroundColor)
```

[Return to Task](#Ch2PreClassQueT5)

#### Task 6


```r
pong_data2_group <- group_by(pong_data2, BackgroundColor, PaddleLength)
pong_data2_hits <- summarise(pong_data2_group, mean_hits = mean(HitOrMiss))
```


```
## `summarise()` has grouped output by 'BackgroundColor'. You can override using the `.groups` argument.
```

* You should find that the number of hits made with the small paddle (50) and the red color background is 0.450655

[Return to Task](#Ch2PreClassQueT6)

### Data Wrangling Application

#### Task 2


```r
library(tidyverse)
```

or


```r
library("tidyverse")
```

* Note, there is no difference between `library(tidyverse)` and `library("tidyverse")` both will work. 

[Return to Task](#Ch2InClassQueT2)

#### Task 3


```r
responses <- read_csv("responses.csv")                  
qformats <- read_csv("qformats.csv")                 
scoring <- read_csv("scoring.csv")                  
pinfo <- read_csv("pinfo.csv")
```

* Note that there is a difference between `responses <- read_csv("responses.csv") ` and `responses <- read_csv(responses.csv) `. You will need quotes around the .csv filename as shown in the code chunk above (e.g. `responses <- read_csv("responses.csv")`), or the code won't work.

[Return to Task](#Ch2InClassQueT3)

#### Task 7 


```r
aq_scores <- rscores %>% 
             group_by(Id) %>% # group by the ID number in column Id
             summarise(AQ = sum(Score)) # sum column Score to obtain AQ scores.
```

[Return to Task](#Ch2InClassQueT7)


#### Task 8


```r
aq_scores2 <- responses %>% 
  pivot_longer(cols = Q1:Q10,
               names_to = "Question",
               values_to = "Response"),
  inner_join(qformats, "Question") %>%
  inner_join(scoring, c("QFormat", "Response")) %>%
             group_by(Id) %>% 
             summarise(AQ = sum(Score))
```

[Return to Task](#Ch2InClassQueT8)

### Practice Your Skills



#### Task 1 - Oldest Participant

* Whether you coded this answer or just read from the data, the Participant with ID Number 3 is the oldest.


```r
oldest_participant <- 3
```

This could also be answered with code. We haven't quite shown you how yet but it would look like this:


```r
oldest_participant_code <- arrange(screening, desc(AGE)) %>% 
  slice(1) %>% 
  pull(ID)
```

[Return to Task](#Ch2AssignQueT1)

#### Task 2 - Arranging D-SPAN

* `arrange()` is the main function here
* You also needed to use `desc()` to sort from high to low


```r
cogtest_sort <- arrange(screening, desc(DSPAN))
```

[Return to Task](#Ch2AssignQueT2)

#### Task 3 - Foreign Language Speakers

1. First group the screening data by FLANG using `group_by()`
2. Next, summarise, paying attention to use the variable names as instructed
3. `n()` is a function that we use within `summarise()` to count how many observations we have. It works like `count()` but you can't use `count()` within `summarise()`
4. `median()` is the function that we use within `summarise()` to calculate the median. Much like we do with `sum()` or `mean()` or `sd()`, etc.


```r
screen_groups <- group_by(screening, FLANG) 
descriptives <- summarise(screen_groups, 
                          n = n(), 
                          median_age = median(AGE))
```

[Return to Task](#Ch2AssignQueT3)

#### Task 4 - Creating Percentage MOCA scores

* `mutate()` is the function to add a new column to data
* Here we are mutating/adding on a column called `MOCA_Perc` which shows a participant's MOCA score divided by 30 and multiplied by 100.


```r
screening <- mutate(screening, MOCA_Perc = (MOCA / 30) * 100)
```

[Return to Task](#Ch2AssignQueT4)

#### Task 5 - Remove the MOCA column

* `select()` is the key function to keep and remove certain columns.
* Two options here; both would give the same dataframe.
* The first option shows how to deselect a column and keep everything else.
* The second option shows how to select all the columns you want.
* Remember that order is very important and you should select the columns in the order you want.

Option 1:


```r
screening <- select(screening, -MOCA)
```

Option 2:


```r
screening <- select(screening, ID, AGE, SEX, HANDEDNESS, EDUCATION, MUSICAL, FLANG, DSPAN, D2, MOCA_Perc)
```

[Return to Task](#Ch2AssignQueT5)

#### Task 6 - Gather the Responses together

* `pivot_longer()` is the function to use here.
* People take a while to understand this function but spend some time looking at the example below and it will start to make some sense.
* The first argument is the data. In this case `responses`.
* The second argument is the name of the columns you want to gather. Here we are gathering all columns between the Q1 column and the Q15 column. Remember that the colon (:) says "from ... to ..." 
    - You do not actually need to write `cols = ` but it makes things clearer.
    - "Gathering" of columns is based on position in the tibble.  If the order of columns in the tibble was Q1 then Q15, the above code would only gather those two columns. As it is, in our tibble, the order, is Q1, Q2, Q3, ... Q15, and therefore the code gathers all the columns between Q1 and Q15.  
    - Colum names are not put in quotes because they exist already in the tibble `responses`.
* The third and fourth arguments are the names of the new columns we are creating; 
    - the first will store the question numbers, `Question`. I.e. put the question names (`names_to = ...`) in a column called "Question". 
    - the second will store the values/responses, `Response`. I.e. put the values/responses to the questions (`values_to = ...`) in a column called "Response".
    - These new column names are put in quotes because they do not already exist in the tibble. This is not always the case but is the case for this function.
    - Note that these names could have been anything but by using these names the code makes more sense.
    - Lastly, you do need to write `names_to = ...` and `values_to = ...` otherwise the columns won't be created correctly.


```r
responses_long <- pivot_longer(responses, 
                         cols = Q1:Q15, 
                         names_to = "Question", 
                         values_to = "RESPONSE")
```

[Return to Task](#Ch2AssignQueT6)

#### Task 7 - Joining the data

* `inner_join()` will combine all common information in two sets of data by a common column or columns.
* Here we are joining the data in `responses_long` with the data in `scoring` by the common column `RESPONSE`.
* Keep in mind that `inner_join()` keeps only the rows that have data in both datasets. It will remove rows that only have data in one dataset.
* When joining two datasets, join by **ALL** common columns when there is more than one column in common.


```r
responses_points <- inner_join(responses_long, scoring, "RESPONSE")
```

[Return to Task](#Ch2AssignQueT7)

#### Task 8 - Working the Pipes

* This is the code we started with.  


```r
participant_groups <- group_by(responses_points, ID)
participant_scores <- summarise(participant_groups, Total_QHC = sum(SCORE))
participant_screening <- inner_join(participant_scores, screening, "ID")
screening_groups_new <- group_by(participant_screening, MUSICAL)
musical_means <- summarise(screening_groups_new, mean_score = mean(Total_QHC))
```

* Below is how to transcribe the above series of functions into a pipeline.
* Remember, when using pipes, the output of the previous function is the input of the subsequent function


```r
musical_means <- group_by(responses_points, ID) %>%
                  summarise(Total_QHC = sum(SCORE)) %>%
                  inner_join(screening, "ID") %>%
                  group_by(MUSICAL) %>%
                  summarise(mean_score = mean(Total_QHC))
```

[Return to Task](#Ch2AssignQueT8)

#### Task 9 - Difference in Musical Means

* People who play music have a QHC score that is 1.53 units higher than people who don't play music.
* You can do this by looking in `musical_means`, reading the values, and doing some quick maths.
* A second option is through code. Code is always better as it can reduce error and is reproducible!


```r
# Option 1
QHC_diff <- 1.53

# Option 2
# You will soon learn the functions to do this by code but here is how you could do it.
QHC_diff_code <- pivot_wider(musical_means, 
                             names_from = "MUSICAL", 
                             values_from = "mean_score") %>% 
  mutate(diff = YES - NO) %>% 
  pull(diff) %>% 
  round(2)
```

[Return to Task](#Ch2AssignQueT9)

